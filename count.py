# -*- coding: utf-8 -*-
"""count.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eoUJIke6Esifbo44737I2ndKArw92fTh
"""

input=[2,4,6,8,12,14,16,18]
def miss_ele(arr):
    mid=int(len(arr)/2)
    n=len(arr)
    if n==3:
      return arr[0]+arr[2]-arr[1]
    elif n==2:
      return int((arr[0]+arr[1])/2)
    elif abs(arr[mid]-arr[0])/(mid)>abs(arr[n-1]-arr[mid])/(n-mid-1):
      return miss_ele(arr[:mid+1])
    else:
      return miss_ele(arr[mid:])
miss_ele(input)

ini=[-1, -4,-8, -16, -20, -24,-28]
miss_ele(ini)

input=[2,4,6,8,10,12,14,16,20]
def miss_ele(arr):
    mid=int(len(arr)/2)
    n=len(arr)
    if n==3:
      return arr[0]+arr[2]-arr[1]
    elif n==2:
      return int((arr[0]+arr[1])/2)
    elif (arr[mid]-arr[0])/(mid)>(arr[n-1]-arr[mid])/(n-mid-1):
      return miss_ele(arr[:mid+1])
    else: return miss_ele(arr[mid:])
miss_ele(input)

a=[1,2,3]
b=[7,8,9]
def no_format(a,b):
  while a[0]==0:
    a=a[1:]
  while b[0]==0:
    b=b[1:]
  n=len(a)
  m=len(b)
  c = [0]*(n+m)
  print(c)
  for i in range(n):
    for j in range(m):
      # print("c",n+m-1+i+j)
      # print("a",n-1-i)
      c[n+m-1-i-j]+=a[n-1-i]*b[m-1-j]
      print(c[n+m-1-i-j])
      if c[n+m-1-i-j]>9:
        c[n+m-2-i-j] = c[n+m-1-i-j]//10+c[n+m-2-i-j]
        c[n+m-1-i-j] = c[n+m-1-i-j]%10
    
  if c[0]==0:
    c=c[1:]
  return c
no_format(a,b)

123*789

def no_add(a):
  while a[0]==0:
    a=a[1:]
  n=len(a)-1

  while n!=-1:
    a[n]+=1
    if a[n]>9:
      a[n]=a[n]%10
      n=n-1
    else: n=-1
  if a[0]==0:
    a[0]=1
    a.append(0)
  return a

no_add([0,0,9,9])

def binary_search(arr,l,r,num):  #"simple binary search code"
    mid=int((l+r)/2)
    if arr[mid]==num:
        return mid
    elif arr[mid]>num:
        return binary_search(arr,l,mid,num)
    else: return binary_search(arr,mid,r,num)

def infinite_array(arr,num):  
    i=0
    while num > arr[2**i] :       # if num to find is greater than number at index 2 power i we increase i by one
        i+=1
    if a[2**i]==num:              # num to find equals number at index 2 power i
        return 2**i
    else: return binary_search(arr,2**(i-1),2**i,num)  # num to find is less than number at index 2 pow i and greater than num at index 2 pow (i-1)
                                                       # then apply binary search between index 2 pow i and 2 pow (i-1)

a=range(300000)

print(infinite_array(a,32))   # returns 32
print(infinite_array(a,31))   # returns 31
print(infinite_array(a,33))     # returns 33
print(infinite_array(a,10000))     # returns 10000
print(infinite_array(a,100000))     # returns 100000

print(infinite_array(a,32))

def water_capacity(arr):
  max_index=arr.index(max(arr))   # find the index of maximum number in array
  capacity=0         
  sum=0
  size=0
 
  for i in range(max_index+1):    # finding water capacity before max index
    if size>arr[i]:
      sum+=size-arr[i]              
    else: 
      capacity+=sum
      sum=0
      size=arr[i]
  size=0
  for j in range(len(arr)-1,max_index-1,-1): # finding water capacity after max index
    if size>arr[j]:
      sum+=size-arr[j]
    else: 
      capacity+=sum
      sum=0
      size=arr[j]
  return capacity

a=[1,1,5,1,3]
print(water_capacity(a))
b=range(10,-1,-1)
print(water_capacity(b))

from math import sqrt
int(sqrt(200))-1

def candies(c,n):
  a=int(sqrt(2*c))
  if a*(a+1)/2>c:
    a=a-1
  elif (a+2)*(a+1)/2<c:      ##"a is no of kids requires to distribute candies acc to given mtd"
    a=a+1
  
  l=a//n        ## "l is complete rotations and r is incomplete rotaion no."
  r=a%n

  arr=[0]*n     ## arr is answer array
  for i in range(r):
    arr[i]=(i+1)*(l+1)+int(n*l*(l+1)/2)     # arr[i] for kids in incomplete and complete rotation 
  for i in range(r,n):
    arr[i]=(i+1)*(l)+int(n*(l-1)*l/2)    # arr[i] for only complete rotations
 
  arr[(r)%(n)]+=int(c-a*(a+1)/2)        # remaining candies
  return arr
candies(4,10)

def candies(c,n):
  a=int(sqrt(2*c))
  if a*(a+1)/2>c:
    a=a-1
  elif a*(a+1)/2<c:
    a=a+1
  l=a//n
  r=a%n

  arr=[0]*n
  for i in range(r):
    arr[i]=(i+1)*(l+1)+int(n*l*(l+1)/2)
  for i in range(r,n):
    arr[i]=(i+1)*(l)+int(n*(l-1)*l/2)
  arr[(r)%(n)]+=int(c-a*(a+1)/2)
  return arr
candies(11,4)

x=candies(1000,1000)

x[45]

count=0
def quick_sort(arr,l,r,count):
  if l==r or l>r:
    return arr , count
  else:
    
    pivot=arr[r]
    index=l
    for i in range(l,r):
      if arr[i]<pivot:
        if arr[index]!=arr[i]:
          count+=1
          arr[index],arr[i]=arr[i],arr[index]
          print(count,arr)
        index+=1
          
    if arr[index]!=pivot:
      arr[index],arr[r] = arr[r] , arr[index]
      count+=1
      print(count,arr)
    arr,count=quick_sort(arr,l,index-1,count)
    arr,count=quick_sort(arr,index+1,r,count)
    return arr , count

quick_sort([2,3,41,9,4,10,21],0,6,count)

b=[2,3,9,4,10]
quick_sort(b,0,4,0)

def selection_sort(arr):
  count=0
  for i in range(len(arr)):
    index=arr.index(min(arr[i:]))
    if i!=index:
      arr[i],arr[index]=arr[index],arr[i]
      count+=1
  return arr, count

selection_sort([2,3,41,9,4,10,21])

